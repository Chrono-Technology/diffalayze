#!/usr/bin/env python3
"""
MSRC Pipeline adapter for diffalayze.

This fetch_target.py reads a pipeline_report.json generated by msrc-patch-pipeline
and downloads the next unprocessed pre/post binary pair from the Symbol Server.

Usage with diffalayze:
    # Set the report path, then run diffalayze normally
    export MSRC_REPORT=/path/to/pipeline_report.json
    export MSRC_WIN_VERSION=11-23H2          # optional filter
    python diffalayze.py msrc_pipeline -a     # -a enables LLM analysis

The adapter maintains a local state file (processed.json) to track which
CVE/binary pairs have already been diffed, so re-running will pick up the
next unprocessed target.
"""
import json
import os
import urllib.request
from pathlib import Path

SCRIPT_DIR = Path(__file__).parent
tracking_file = SCRIPT_DIR / "version.log"
state_file = SCRIPT_DIR / "processed.json"


def _load_state() -> dict:
    if state_file.exists():
        return json.loads(state_file.read_text(encoding="utf-8"))
    return {"processed": []}


def _save_state(state: dict):
    state_file.write_text(json.dumps(state, indent=2), encoding="utf-8")


def download_file(url: str, dest: Path):
    try:
        urllib.request.urlretrieve(url, dest)
    except Exception as e:
        raise RuntimeError(f"[!] Download error: {e}")


def check_and_download():
    """
    diffalayze interface: returns (old_path, new_path) or False.
    Reads MSRC_REPORT env var to find the pipeline_report.json.
    Downloads the next unprocessed CVE/binary pair.
    """
    report_path = os.environ.get("MSRC_REPORT", "")
    if not report_path or not Path(report_path).exists():
        # Try default locations
        for candidate in [
            SCRIPT_DIR / "pipeline_report.json",
            Path("pipeline_report.json"),
            Path("patch_diff_output/pipeline_report.json"),
        ]:
            if candidate.exists():
                report_path = str(candidate)
                break
        else:
            print("[!] No pipeline_report.json found. Set MSRC_REPORT env var.")
            return "", ""

    win_filter = os.environ.get("MSRC_WIN_VERSION", "")

    with open(report_path) as f:
        report = json.load(f)

    state = _load_state()
    processed_keys = set(state.get("processed", []))

    for target in report.get("targets", []):
        cve_id = target.get("cve_id", "")
        binary = target.get("binary", "")
        pre = target.get("pre_patch")
        post = target.get("post_patch")

        if not pre or not post:
            continue

        pre_url = pre.get("download_url", "")
        post_url = post.get("download_url", "")
        if not pre_url or not post_url:
            continue

        target_key = f"{cve_id}_{binary}"
        if target_key in processed_keys:
            continue

        # Found an unprocessed target
        pre_version = pre.get("version", "unknown")
        post_version = post.get("version", "unknown")

        print(f"[*] Target: {cve_id} / {binary}")
        print(f"    Pre:  {pre_version} -> {pre_url}")
        print(f"    Post: {post_version} -> {post_url}")

        old_path = SCRIPT_DIR / f"old.{binary}"
        new_path = SCRIPT_DIR / f"new.{binary}"

        print(f"[*] Downloading pre-patch ({pre_version})...")
        download_file(pre_url, old_path)

        print(f"[*] Downloading post-patch ({post_version})...")
        download_file(post_url, new_path)

        # Write metadata for LLM context
        meta = {
            "cve_id": cve_id,
            "binary": binary,
            "impact": target.get("impact", ""),
            "severity": target.get("severity", ""),
            "cvss": target.get("cvss", ""),
            "cwe": target.get("cwe", ""),
            "executive_summary": target.get("executive_summary", ""),
            "pre_version": pre_version,
            "post_version": post_version,
        }
        meta_path = SCRIPT_DIR / "current_target.json"
        meta_path.write_text(json.dumps(meta, indent=2), encoding="utf-8")

        # Mark as processed
        state["processed"].append(target_key)
        state["current"] = target_key
        _save_state(state)

        tracking_file.write_text(post_url + "\n", encoding="utf-8")

        return str(old_path), str(new_path)

    print("[*] All targets in the report have been processed.")
    return False
